%# -*- coding: utf-8-unix -*-
%%==================================================
%% conclusion.tex for SJTUThesis
%% Encoding: UTF-8
%%==================================================

\chapter{总结与展望}

本部分总结了Fornax目前已经完成的工作，并对Fornax的未来进行了展望。

\section{工作总结}

本课题基于容器技术和容器集群技术，实现了一个用于版本管理与发布的系统，名为Fornax。通过Fornax，用户可以对自己的代码进行持续集成，并且在持续集成结束后，将代码打包成容器镜像的格式，上传至远端的仓库。在部署时，可以通过Fornax的持续部署，根据新打包的镜像直接在指定的集群上运行容器。同时，Fornax允许用户在构建镜像时定义自己的操作，使得可以在打包镜像的同时时完成用户定义的逻辑。

并且Fornax在实现时使用了容器虚拟化技术来进行构建任务之间的隔离。一次构建任务由一个或多个容器完成，容器间通过网络互连，而不同构建任务之间的容器之间互相不感知。同时Fornax是一个异步的、无状态的服务，因此通过第三方的负载均衡器的代理，可以实现分布式部署，提高Fornax的吞吐量以及可用性。

在最后，课题针对Fornax的功能进行了端到端的测试，测试覆盖了Fornax的全部正常工作流与一些异常流。通过测试的方式来验证Fornax的功能符合规约，同时证明功能实现的完整性。

\section{未来的工作}

Fornax的代码托管在Github上，而在Github的问题页面，已经积累了大大小小四十多个有关Fornax的问题，其中有优化，也有因为Bug而导致的问题。由此可见目前Fornax还不是非常完善，有很多工作需要未来一点点去完成。下面将从几个需要关注的方面着手，展望Fornax未来需要解决的问题。

首先是关于日志模块，在日志推送时，因为最开始使用了本地存储的方式，所以在后续引入Kafka来将日志推送至分布式消息中间件的实现中仍然有本地存储的依赖。目前每多一个构建请求，都要创建一个线程去监听本地日志文件的变化，然后将其推送给Kafka。后续应该调研是否仍然有必要使用本地存储，是否可以直接将日志推送至Kafka消息中间件中。这样可以节省很多的处理器资源。

其次是关于持续集成模块，在目前，虽然持续集成已经可以进行，但是还存在一些问题。比如，在构建失败时，有可能因为路径问题而没有回收构建时产生的垃圾。另外，目前对于用户所使用的硬件资源并没有作出限制。当用户在一次构建中创建出过多容器占用了整个机器的硬件资源时，会影响其他构建任务的执行。而为了解决这一问题，需要比较大的改造。对于用户占用资源的控制，可以分为三个维度，分别是对容器的资源限制，对构建任务的资源限制，和对用户的资源限制。对容器的资源限制是指要限定每个容器可以使用的硬件资源，这由内核的特性提供支持。内核中的cgroup和namespace特性使得这不需要Fornax实现。而对于构建任务的资源限制是指在一次构建中所启动的所有容器使用的硬件资源的总和应该进行限制。对于用户的资源限制，是指用户的多次构建任务所占用的硬件资源的总和也应该予以限制。三个维度的资源限制都是有必要的，而目前Fornax只能做到第一个维度的限制。对于第二个维度的限制，需要Fornax维护构建任务中所有容器的信息，并实时地进行计算。而对于第三个维度的限制，则相对比较困难，需要将用户的构建信息写入数据库，来进行判断。

类似这样的问题还有诸如在一次请求中数据库访问次数过多，以及用户校验以及鉴权等等。这些问题都是未来Fornax需要解决的问题。